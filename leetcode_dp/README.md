# 动态规划

## Reference

- https://leetcode.com/discuss/post/458695/dynamic-programming-patterns-by-aatalyk-pmgr/
- https://leetcode.com/list/55ac4kuc - (Min - max path to target)
- https://leetcode.com/list/55ajm50i - (distinct ways)
- https://leetcode.com/list/55aj8s16 - (merging intervals)
- https://leetcode.com/list/55afh7m7 - (DP on strings)
- https://leetcode.com/list/55af7bu7 - (decision making)


## 自顶向下和自底向上

动态规划是一种通过把原问题分解为相对简单的子问题来求解复杂问题的方法，自顶向下（Top-Down）和自底向上（Bottom-Up）是动态规划的两种常见实现方式，下面分别对它们进行详细解释：

### 自顶向下（递归 + 记忆化）
- **基本思路**：从问题的最终目标状态开始，通过递归不断地将大问题分解为更小的子问题，直到子问题简单到可以直接求解。在递归过程中，使用一个数据结构（如数组、哈希表等）来记录已经解决的子问题的结果，当再次遇到相同的子问题时，直接从记录中获取结果，而不需要重新计算，这种技术称为记忆化（Memoization）。
- **示例**：以计算斐波那契数列第 `n` 项 `F(n)` 为例，斐波那契数列的定义为 `F(n) = F(n - 1) + F(n - 2)`，其中 `F(0) = 0`，`F(1) = 1`。
```python
memo = {}
def fib_top_down(n):
    if n in memo:
        return memo[n]
    if n == 0 or n == 1:
        result = n
    else:
        result = fib_top_down(n - 1) + fib_top_down(n - 2)
    memo[n] = result
    return result
```
在这个示例中，`memo` 用于存储已经计算过的斐波那契数。每次调用 `fib_top_down(n)` 时，先检查 `n` 是否在 `memo` 中，如果在则直接返回结果，否则递归计算 `F(n)` 并将结果存入 `memo` 中。

### 自底向上（迭代）
- **基本思路**：从最基础、最简单的子问题开始，按照一定的顺序逐步求解更大的子问题，直到最终解决原问题。通常使用迭代的方式，通过循环来依次计算每个子问题的解，并将其保存下来，以便后续子问题的计算可以直接使用这些结果。
- **示例**：同样以计算斐波那契数列第 `n` 项 `F(n)` 为例：
```python
def fib_bottom_up(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    a, b = 0, 1
    for _ in range(1, n):
        a, b = b, a + b
    return b
```
在这个示例中，从最基础的 `F(0)` 和 `F(1)` 开始，通过迭代计算依次得到 `F(2)` 到 `F(n)` 的值，最终返回 `F(n)` 的结果。

### 两者的比较
- **自顶向下**：优点是代码结构清晰，符合人们对问题的自然思考方式，容易实现和理解。缺点是递归调用可能会带来一定的性能开销（如函数调用栈的消耗），并且在处理大规模问题时可能会导致栈溢出。
- **自底向上**：优点是没有递归调用的开销，效率较高，而且可以更好地控制计算顺序和资源使用。缺点是代码可能相对不够直观，需要更仔细地设计计算顺序和状态转移方程。

总之，自顶向下和自底向上都是解决动态规划问题的有效方法，具体使用哪种方法可以根据问题的特点和个人的编程习惯来决定。 

## 判断一个算法题能否使用动态规划

判断一个算法题能否使用动态规划，可从以下几个关键特征入手：

### 1. 最优子结构性质
- **定义**：问题的最优解包含其子问题的最优解。也就是说，一个大问题的最优解可以由它的各个子问题的最优解组合而成。
- **示例**：在爬楼梯问题中，要到达第 `n` 级台阶的最小花费，依赖于到达第 `n - 1` 级台阶和第 `n - 2` 级台阶的最小花费，因为到达第 `n` 级台阶只能从这两个位置上来。到达第 `n - 1` 级和第 `n - 2` 级台阶的最小花费就是原问题的子问题的最优解，这就满足了最优子结构性质。

### 2. 子问题重叠性质
- **定义**：在求解问题的过程中，会多次重复地求解相同的子问题。动态规划通过记录子问题的解，避免了重复计算，从而提高了算法效率。
- **示例**：计算斐波那契数列时，`F(n) = F(n - 1) + F(n - 2)`，在计算 `F(n)` 时会多次计算 `F(n - 2)`、`F(n - 3)` 等相同的子问题。如果不使用动态规划，会进行大量的重复计算；而使用动态规划（如记忆化搜索或迭代），可以将已经计算过的子问题的结果保存下来，再次遇到相同子问题时直接使用保存的结果。

### 3. 无后效性
- **定义**：某阶段的状态一旦确定，就不受这个状态以后决策的影响。也就是说，当前状态只与之前的状态有关，而与未来的决策无关。
- **示例**：在背包问题中，当前背包的剩余容量和已经选择的物品状态决定了当前的状态，后续选择物品时只需要考虑当前状态，而不需要关心之前是如何达到这个状态的。

### 具体判断步骤
- **分析问题的最优解结构**：尝试将问题分解为更小的子问题，并思考大问题的最优解是否可以由子问题的最优解推导出来。
- **检查子问题是否重叠**：在分解问题的过程中，观察是否会多次遇到相同的子问题。
- **验证无后效性**：确定每个状态的决策是否只依赖于当前状态，而与未来的决策无关。

如果一个问题同时满足最优子结构性质、子问题重叠性质和无后效性，那么通常可以使用动态规划来解决。

### 举例说明
比如，给定一个整数数组 `nums` 和一个目标值 `target`，要求从数组中选取一些数，使得它们的和等于 `target`，并且选取的数的个数最少。
- **最优子结构**：要得到和为 `target` 的最少选取数，对于数组中的每个数 `nums[i]`，可以考虑包含 `nums[i]` 和不包含 `nums[i]` 的情况，这就将问题分解为子问题。而原问题的最优解（最少选取数）可以由子问题的最优解推导出来。
- **子问题重叠**：在求解过程中，可能会多次遇到相同的和 `sum` 和剩余数组的情况，这些就是重叠的子问题。
- **无后效性**：当前的和 `sum` 和已经选取的数的状态只与之前的选择有关，后续的选择只需要基于当前状态进行，与未来的选择无关。所以这个问题可以使用动态规划来解决。 


再详细解释一下为什么对于“从数组 `nums` 中选取一些数，使得它们的和等于 `target`，并且选取的数的个数最少”这个问题，原问题的最优解（最少选取数）可以由子问题的最优解推导出来。

假设我们有一个数组 `nums = [1, 2, 3]`，目标值 `target = 5`。

1. **定义子问题**：
   我们的目标是找到和为 `target` 的最少选取数。对于数组中的每个数 `nums[i]`，我们可以将问题分解为两个子问题：
   - 子问题一：包含 `nums[i]` 的情况下，找到和为 `target - nums[i]` 的最少选取数。
   - 子问题二：不包含 `nums[i]` 的情况下，找到和为 `target` 的最少选取数。

   例如，对于 `nums[0] = 1`，我们考虑：
   - 子问题一：包含 `1`，那么我们需要找到和为 `target - 1 = 5 - 1 = 4` 的最少选取数。
   - 子问题二：不包含 `1`，那么我们还是要找到和为 `target = 5` 的最少选取数（但此时数组中少了 `1` 这个选择）。

2. **推导原问题的最优解**：
   原问题的最优解（和为 `target` 的最少选取数）可以通过比较这两个子问题的解来得到。
   - 如果子问题一（包含 `nums[i]` 的情况）得到的选取数加上 `1`（因为我们选了 `nums[i]` 这一个数），比子问题二（不包含 `nums[i]` 的情况）得到的选取数更少，那么原问题的最优解就是子问题一的解加上 `1`。
   - 反之，如果子问题二的选取数更少，那么原问题的最优解就是子问题二的解。

   以我们的例子来说：
   - 对于 `nums[0] = 1`，当我们考虑子问题一（和为 `4`）时，假设我们通过递归或其他方式找到了和为 `4` 的最少选取数是 `2`（比如选 `1` 和 `3`），那么包含 `1` 的情况下，和为 `5` 的选取数就是 `2 + 1 = 3`（因为选了 `1` 以及和为 `4` 的两个数）。
   - 对于子问题二（不包含 `1`，和为 `5`），假设我们发现最少选取数是 `2`（比如选 `2` 和 `3`）。
   - 比较这两个结果，我们发现子问题二的结果更优，所以原问题（和为 `5` 的最少选取数）的最优解就是 `2`。

通过这样的方式，我们将原问题不断分解为子问题，并利用子问题的最优解来推导出原问题的最优解，这就是最优子结构性质的体现。也就是说，我们可以通过求解一系列相关的子问题，最终得到原问题的最优解。 


## 问题分类

代码注意，自底向上时，写循环要保证每一个子问题的解都解出来了.

### 到达目标的最小（最大）路径

- 问题陈述
    - 给定一个目标，找到到达目标的最小（最大）代价/路径/总和

- 方法
    - 在当前状态之前的所有可能路径中选择最小（最大）路径，然后为当前状态添加值

        ```c++
        routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]
        ```

- 题目参考：https://leetcode.com/list/55ac4kuc - (Min - max path to target)